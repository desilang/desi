package c

import (
	"bytes"
	"strconv"

	"github.com/desilang/desi/compiler/internal/ast"
	"github.com/desilang/desi/compiler/internal/term"
)

// EmitFile generates a small C translation unit from a parsed Desi file.
// Stage-0: translate `def main() -> i32` body with:
//   - let/assign of int or string literals (and idents on RHS)
//   - io.println(x) for strings/ints/idents
//   - return <int>  (default return 0 at end)
func EmitFile(f *ast.File) string {
	var b bytes.Buffer
	term.Wprintf(&b, "/* generated by desic (Stage-0) */\n")
	term.Wprintf(&b, "#include <stdint.h>\n")
	term.Wprintf(&b, "#include <stdio.h>\n\n")

	if main := findMain(f); main != nil {
		emitMain(&b, main)
	} else {
		// Fallback: a do-nothing main
		term.Wprintf(&b, "int main(void) { return 0; }\n")
	}
	return b.String()
}

func findMain(f *ast.File) *ast.FuncDecl {
	for _, d := range f.Decls {
		if fn, ok := d.(*ast.FuncDecl); ok && fn.Name == "main" {
			return fn
		}
	}
	return nil
}

func emitMain(b *bytes.Buffer, fn *ast.FuncDecl) {
	term.Wprintf(b, "int main(void) {\n")
	for _, s := range fn.Body {
		emitStmt(b, 2, s)
	}
	// Ensure a final return (harmless if unreachable).
	term.Wprintf(b, "  return 0;\n")
	term.Wprintf(b, "}\n")
}

func emitStmt(b *bytes.Buffer, indent int, s ast.Stmt) {
	ind := spaces(indent)
	switch st := s.(type) {
	case *ast.LetStmt:
		cExpr, kind := cExprFor(st.Expr)
		switch kind {
		case "str":
			term.Wprintf(b, "%sconst char* %s = %s;\n", ind, st.Name, cExpr)
		case "int":
			term.Wprintf(b, "%sint %s = %s;\n", ind, st.Name, cExpr)
		default:
			// unknown type: declare as int as a safe default
			term.Wprintf(b, "%sint %s = %s; /* unknown type, default int */\n", ind, st.Name, cExpr)
		}

	case *ast.AssignStmt:
		cExpr, _ := cExprFor(st.Expr)
		term.Wprintf(b, "%s%s = %s;\n", ind, st.Name, cExpr)

	case *ast.ExprStmt:
		// io.println(...)
		if call, ok := st.Expr.(*ast.CallExpr); ok && isIoPrintln(call) {
			emitPrintln(b, indent, call)
			return
		}
		// otherwise drop on floor (Stage-0)
		term.Wprintf(b, "%s/* expr stmt not lowered */;\n", ind)

	case *ast.ReturnStmt:
		if st.Expr == nil {
			term.Wprintf(b, "%sreturn 0;\n", ind)
			return
		}
		cExpr, kind := cExprFor(st.Expr)
		if kind != "int" {
			// main must return int; coerce unknown to 0
			if kind == "str" {
				term.Wprintf(b, "%s/* returning string from main not allowed; force 0 */\n", ind)
			}
			term.Wprintf(b, "%sreturn 0;\n", ind)
			return
		}
		term.Wprintf(b, "%sreturn %s;\n", ind, cExpr)

	default:
		term.Wprintf(b, "%s/* stmt not lowered */\n", ind)
	}
}

func isIoPrintln(c *ast.CallExpr) bool {
	// Match callee: FieldExpr(IdentExpr("io"), "println")
	if fe, ok := c.Callee.(*ast.FieldExpr); ok {
		if fe.Name == "println" {
			if id, ok := fe.X.(*ast.IdentExpr); ok && id.Name == "io" {
				return true
			}
		}
	}
	return false
}

func emitPrintln(b *bytes.Buffer, indent int, call *ast.CallExpr) {
	ind := spaces(indent)
	if len(call.Args) != 1 {
		term.Wprintf(b, "%s/* println expects 1 arg */\n", ind)
		return
	}
	arg := call.Args[0]
	cExpr, kind := cExprFor(arg)
	switch kind {
	case "str":
		term.Wprintf(b, "%sprintf(\"%%s\\n\", %s);\n", ind, cExpr)
	case "int":
		term.Wprintf(b, "%sprintf(\"%%d\\n\", %s);\n", ind, cExpr)
	default:
		// Try printing as string pointer; if not, fall back
		term.Wprintf(b, "%s/* println unknown kind; attempt as int */\n", ind)
		term.Wprintf(b, "%sprintf(\"%%d\\n\", %s);\n", ind, cExpr)
	}
}

// cExprFor converts a tiny subset of AST Expr into a C expression string
// and a coarse "kind": "int", "str", or "" (unknown).
func cExprFor(e ast.Expr) (string, string) {
	switch v := e.(type) {
	case *ast.IntLit:
		// Keep numeric base as-is (supports 0x.., 0b.. will not be recognized by C; normalize decimal)
		if stringsHasPrefixAny(v.Value, "0x", "0X") {
			// C supports 0x; pass through
			return v.Value, "int"
		}
		if stringsHasPrefixAny(v.Value, "0b", "0B") {
			// Convert binary to decimal for C
			if n, err := strconv.ParseInt(v.Value[2:], 2, 64); err == nil {
				return strconv.FormatInt(n, 10), "int"
			}
			return "0", "int"
		}
		return v.Value, "int"
	case *ast.StrLit:
		// Value already includes quotes per lexer; pass through
		return v.Value, "str"
	case *ast.IdentExpr:
		// Unknown type; print as int unless otherwise known
		return v.Name, ""
	case *ast.BinaryExpr:
		// Only handle arithmetic on ints conservatively
		l, lk := cExprFor(v.Left)
		r, rk := cExprFor(v.Right)
		if lk == "int" && rk == "int" {
			return "(" + l + " " + v.Op + " " + r + ")", "int"
		}
		return "(" + l + " " + v.Op + " " + r + ")", ""
	case *ast.UnaryExpr:
		x, xk := cExprFor(v.X)
		if xk == "int" {
			return "(" + v.Op + x + ")", "int"
		}
		return "(" + v.Op + x + ")", ""
	case *ast.CallExpr:
		// Only recognized call: io.println(...) handled by caller; anything else unknown
		return "/*call*/0", ""
	case *ast.IndexExpr:
		// Not supported yet
		return "/*index*/0", ""
	case *ast.FieldExpr:
		// Might be io.println callee; as expression, unknown
		return "/*field*/0", ""
	case *ast.BoolLit:
		if v.Value {
			return "1", "int"
		}
		return "0", "int"
	default:
		return "0", ""
	}
}

func spaces(n int) string {
	if n <= 0 {
		return ""
	}
	return string(bytes.Repeat([]byte(" "), n))
}

// helpers
func stringsHasPrefixAny(s string, p1, p2 string) bool {
	return len(s) >= len(p1) && s[:len(p1)] == p1 || (len(s) >= len(p2) && s[:len(p2)] == p2)
}
