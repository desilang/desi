package c

import (
	"bytes"
	"strconv"
	"strings"

	"github.com/desilang/desi/compiler/internal/ast"
	"github.com/desilang/desi/compiler/internal/check"
	"github.com/desilang/desi/compiler/internal/term"
)

// ---- public entry ----

func EmitFile(f *ast.File, info *check.Info) string {
	var b bytes.Buffer
	term.Wprintf(&b, "/* generated by desic (Stage-0) */\n")
	term.Wprintf(&b, "#include <stdint.h>\n")
	term.Wprintf(&b, "#include <stdio.h>\n\n")

	sigs := collectFuncSigs(f)

	// Prototypes for non-main
	for _, d := range f.Decls {
		if fn, ok := d.(*ast.FuncDecl); ok && fn.Name != "main" {
			term.Wprintf(&b, "static %s %s(%s);\n",
				cType(sigs[fn.Name].ret), fn.Name, cParamList(fn))
		}
	}
	if len(sigs) > 0 {
		term.Wprintf(&b, "\n")
	}

	// Definitions (non-main first)
	for _, d := range f.Decls {
		if fn, ok := d.(*ast.FuncDecl); ok && fn.Name != "main" {
			emitFunc(&b, fn, sigs, info, false)
			term.Wprintf(&b, "\n")
		}
	}
	// Main last (if present)
	if m := findMain(f); m != nil {
		emitFunc(&b, m, sigs, info, true)
	}
	return b.String()
}

// ---- signatures & helpers ----

type sig struct {
	ret    string // "int"|"str"|"void"
	params []string
}

func collectFuncSigs(f *ast.File) map[string]sig {
	m := make(map[string]sig)
	for _, d := range f.Decls {
		fn, ok := d.(*ast.FuncDecl)
		if !ok {
			continue
		}
		s := sig{ret: typeToKind(fn.Ret)}
		for _, p := range fn.Params {
			s.params = append(s.params, typeToKind(p.Type))
		}
		m[fn.Name] = s
	}
	return m
}

func findMain(f *ast.File) *ast.FuncDecl {
	for _, d := range f.Decls {
		if fn, ok := d.(*ast.FuncDecl); ok && fn.Name == "main" {
			return fn
		}
	}
	return nil
}

func typeToKind(t string) string {
	t = strings.TrimSpace(strings.ToLower(t))
	switch t {
	case "", "void":
		return "void"
	case "i32", "int", "u32", "bool":
		return "int"
	case "str", "string":
		return "str"
	default:
		// unknown user type: treat as int for stage-0 codegen
		return "int"
	}
}

func cType(kind string) string {
	switch kind {
	case "void":
		return "void"
	case "str":
		return "const char*"
	default:
		return "int"
	}
}

func cParamList(fn *ast.FuncDecl) string {
	var parts []string
	for _, p := range fn.Params {
		parts = append(parts, cType(typeToKind(p.Type))+" "+p.Name)
	}
	return strings.Join(parts, ", ")
}

// ---- function/code emission ----

type env struct {
	fn      *ast.FuncDecl
	sigs    map[string]sig
	vars    map[string]string // name -> kind ("int"/"str")
	retKind string
}

func emitFunc(b *bytes.Buffer, fn *ast.FuncDecl, sigs map[string]sig, info *check.Info, isMain bool) {
	e := &env{
		fn:      fn,
		sigs:    sigs,
		vars:    map[string]string{},
		retKind: typeToKind(fn.Ret),
	}
	// seed params
	for i, p := range fn.Params {
		e.vars[p.Name] = typeToKind(p.Type)
		_ = i
	}

	// signature
	if isMain {
		term.Wprintf(b, "int main(void) {\n")
	} else {
		term.Wprintf(b, "static %s %s(%s) {\n",
			cType(e.retKind), fn.Name, cParamList(fn))
	}

	// body
	for _, s := range fn.Body {
		emitStmt(b, 2, s, e)
	}

	// default return if needed
	if e.retKind == "void" {
		term.Wprintf(b, "}\n")
	} else {
		term.Wprintf(b, "  return 0;\n")
		term.Wprintf(b, "}\n")
	}
}

func emitStmt(b *bytes.Buffer, indent int, s ast.Stmt, e *env) {
	ind := spaces(indent)
	switch st := s.(type) {
	case *ast.LetStmt:
		cExpr, kind := cExprFor(st.Expr, e)
		if kind == "" {
			kind = "int"
		}
		e.vars[st.Name] = kind
		term.Wprintf(b, "%s%s %s = %s;\n", ind, cType(kind), st.Name, cExpr)

	case *ast.AssignStmt:
		cExpr, _ := cExprFor(st.Expr, e)
		term.Wprintf(b, "%s%s = %s;\n", ind, st.Name, cExpr)

	case *ast.ExprStmt:
		// io.println(...)
		if call, ok := st.Expr.(*ast.CallExpr); ok && isIoPrintln(call) {
			emitPrintln(b, indent, call, e)
			return
		}
		// generic call/expression (drop result)
		cx, _ := cExprFor(st.Expr, e)
		term.Wprintf(b, "%s(void)(%s);\n", ind, cx)

	case *ast.ReturnStmt:
		if st.Expr == nil {
			if e.retKind == "void" {
				term.Wprintf(b, "%sreturn;\n", ind)
			} else {
				term.Wprintf(b, "%sreturn 0;\n", ind)
			}
			return
		}
		cExpr, kind := cExprFor(st.Expr, e)
		if e.retKind == "int" && kind != "int" {
			term.Wprintf(b, "%s/* non-int return; force 0 */\n", ind)
			term.Wprintf(b, "%sreturn 0;\n", ind)
			return
		}
		if e.retKind == "str" && kind != "str" {
			term.Wprintf(b, "%s/* non-str return; force \"\" */\n", ind)
			term.Wprintf(b, "%sreturn \"\";\n", ind)
			return
		}
		term.Wprintf(b, "%sreturn %s;\n", ind, cExpr)

	case *ast.IfStmt:
		cond, _ := cExprFor(st.Cond, e)
		term.Wprintf(b, "%sif (%s) {\n", ind, cond)
		for _, s2 := range st.Then {
			emitStmt(b, indent+2, s2, e)
		}
		term.Wprintf(b, "%s}", ind)
		// elif chain
		for _, el := range st.Elifs {
			ec, _ := cExprFor(el.Cond, e)
			term.Wprintf(b, " else if (%s) {\n", ec)
			for _, s2 := range el.Body {
				emitStmt(b, indent+2, s2, e)
			}
			term.Wprintf(b, "%s}", ind)
		}
		// else
		if st.Else != nil {
			term.Wprintf(b, " else {\n")
			for _, s2 := range st.Else {
				emitStmt(b, indent+2, s2, e)
			}
			term.Wprintf(b, "%s}\n", ind)
		} else {
			term.Wprintf(b, "\n")
		}

	default:
		term.Wprintf(b, "%s/* stmt not lowered */\n", ind)
	}
}

func isIoPrintln(c *ast.CallExpr) bool {
	if fe, ok := c.Callee.(*ast.FieldExpr); ok && fe.Name == "println" {
		if id, ok := fe.X.(*ast.IdentExpr); ok && id.Name == "io" {
			return true
		}
	}
	return false
}

// For now println supports a single arg (string/int/ident); PR-3 will make it variadic.
func emitPrintln(b *bytes.Buffer, indent int, call *ast.CallExpr, e *env) {
	ind := spaces(indent)
	if len(call.Args) != 1 {
		term.Wprintf(b, "%s/* println expects 1 arg */\n", ind)
		return
	}
	arg := call.Args[0]
	cExpr, kind := cExprFor(arg, e)
	switch kind {
	case "str":
		term.Wprintf(b, "%sprintf(\"%%s\\n\", %s);\n", ind, cExpr)
	case "int":
		term.Wprintf(b, "%sprintf(\"%%d\\n\", %s);\n", ind, cExpr)
	default:
		term.Wprintf(b, "%s/* println unknown kind; treat as int */\n", ind)
		term.Wprintf(b, "%sprintf(\"%%d\\n\", %s);\n", ind, cExpr)
	}
}

// ---- expressions ----

func cExprFor(e ast.Expr, env *env) (string, string) {
	switch v := e.(type) {
	case *ast.IntLit:
		if hasPrefixAny(v.Value, "0b", "0B") {
			if n, err := strconv.ParseInt(v.Value[2:], 2, 64); err == nil {
				return strconv.FormatInt(n, 10), "int"
			}
			return "0", "int"
		}
		return v.Value, "int"
	case *ast.StrLit:
		return v.Value, "str"
	case *ast.BoolLit:
		if v.Value {
			return "1", "int"
		}
		return "0", "int"
	case *ast.IdentExpr:
		if k, ok := env.vars[v.Name]; ok {
			return v.Name, k
		}
		// might be a function name only in a call; as a bare ident treat as int var
		return v.Name, "int"
	case *ast.UnaryExpr:
		x, k := cExprFor(v.X, env)
		return "(" + v.Op + " " + x + ")", k
	case *ast.BinaryExpr:
		l, lk := cExprFor(v.Left, env)
		r, rk := cExprFor(v.Right, env)
		k := ""
		if lk == "str" || rk == "str" {
			k = "str" // (note: real concat later)
		} else if lk == "int" && rk == "int" {
			k = "int"
		}
		return "(" + l + " " + v.Op + " " + r + ")", k
	case *ast.FieldExpr:
		// could be io.println callee; as value unknown
		return "0", ""
	case *ast.IndexExpr:
		return "0", ""
	case *ast.CallExpr:
		// user function?
		if id, ok := v.Callee.(*ast.IdentExpr); ok {
			if fs, ok := env.sigs[id.Name]; ok {
				var args []string
				for _, a := range v.Args {
					ax, _ := cExprFor(a, env)
					args = append(args, ax)
				}
				return id.Name + "(" + strings.Join(args, ", ") + ")", fs.ret
			}
		}
		// unknown call
		return "0", ""
	default:
		return "0", ""
	}
}

func spaces(n int) string {
	if n <= 0 {
		return ""
	}
	return string(bytes.Repeat([]byte(" "), n))
}

func hasPrefixAny(s string, p1, p2 string) bool {
	return (len(s) >= len(p1) && s[:len(p1)] == p1) ||
		(len(s) >= len(p2) && s[:len(p2)] == p2)
}
