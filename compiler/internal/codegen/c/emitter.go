package c

import (
	"bytes"
	"strconv"

	"github.com/desilang/desi/compiler/internal/ast"
	"github.com/desilang/desi/compiler/internal/check"
	"github.com/desilang/desi/compiler/internal/term"
)

// EmitFile generates a small C translation unit from a parsed Desi file.
// Stage-0: translate `def main() -> i32` with basic let/assign/return and io.println.
func EmitFile(f *ast.File, info *check.Info) string {
	var b bytes.Buffer
	term.Wprintf(&b, "/* generated by desic (Stage-0) */\n")
	term.Wprintf(&b, "#include <stdint.h>\n")
	term.Wprintf(&b, "#include <stdio.h>\n\n")

	if main := findMain(f); main != nil {
		emitMain(&b, main, info)
	} else {
		term.Wprintf(&b, "int main(void) { return 0; }\n")
	}
	return b.String()
}

func findMain(f *ast.File) *ast.FuncDecl {
	for _, d := range f.Decls {
		if fn, ok := d.(*ast.FuncDecl); ok && fn.Name == "main" {
			return fn
		}
	}
	return nil
}

func emitMain(b *bytes.Buffer, fn *ast.FuncDecl, info *check.Info) {
	term.Wprintf(b, "int main(void) {\n")
	for _, s := range fn.Body {
		emitStmt(b, 2, s, info)
	}
	term.Wprintf(b, "  return 0;\n")
	term.Wprintf(b, "}\n")
}

func emitStmt(b *bytes.Buffer, indent int, s ast.Stmt, info *check.Info) {
	ind := spaces(indent)
	switch st := s.(type) {
	case *ast.LetStmt:
		k := info.Vars[st.Name]
		cExpr, _ := cExprFor(st.Expr, info)
		switch k {
		case check.KindStr:
			term.Wprintf(b, "%sconst char* %s = %s;\n", ind, st.Name, cExpr)
		case check.KindInt, check.KindUnknown, check.KindBool:
			// default to int for unknown/bool in Stage-0 C
			term.Wprintf(b, "%sint %s = %s;\n", ind, st.Name, cExpr)
		}

	case *ast.AssignStmt:
		cExpr, _ := cExprFor(st.Expr, info)
		term.Wprintf(b, "%s%s = %s;\n", ind, st.Name, cExpr)

	case *ast.ExprStmt:
		// io.println(...)
		if call, ok := st.Expr.(*ast.CallExpr); ok && isIoPrintln(call) {
			emitPrintln(b, indent, call, info)
			return
		}
		term.Wprintf(b, "%s/* expr stmt not lowered */;\n", ind)

	case *ast.ReturnStmt:
		if st.Expr == nil {
			term.Wprintf(b, "%sreturn 0;\n", ind)
			return
		}
		cExpr, kind := cExprFor(st.Expr, info)
		if kind != "int" {
			term.Wprintf(b, "%s/* non-int return; force 0 */\n", ind)
			term.Wprintf(b, "%sreturn 0;\n", ind)
			return
		}
		term.Wprintf(b, "%sreturn %s;\n", ind, cExpr)

	default:
		term.Wprintf(b, "%s/* stmt not lowered */\n", ind)
	}
}

func isIoPrintln(c *ast.CallExpr) bool {
	if fe, ok := c.Callee.(*ast.FieldExpr); ok && fe.Name == "println" {
		if id, ok := fe.X.(*ast.IdentExpr); ok && id.Name == "io" {
			return true
		}
	}
	return false
}

func emitPrintln(b *bytes.Buffer, indent int, call *ast.CallExpr, info *check.Info) {
	ind := spaces(indent)
	if len(call.Args) != 1 {
		term.Wprintf(b, "%s/* println expects 1 arg */\n", ind)
		return
	}
	arg := call.Args[0]
	cExpr, kind := cExprFor(arg, info)
	switch kind {
	case "str":
		term.Wprintf(b, "%sprintf(\"%%s\\n\", %s);\n", ind, cExpr)
	case "int":
		term.Wprintf(b, "%sprintf(\"%%d\\n\", %s);\n", ind, cExpr)
	default:
		term.Wprintf(b, "%s/* println unknown kind; treat as int */\n", ind)
		term.Wprintf(b, "%sprintf(\"%%d\\n\", %s);\n", ind, cExpr)
	}
}

// cExprFor returns a C expression string and a coarse kind label ("int"/"str"/"").
func cExprFor(e ast.Expr, info *check.Info) (string, string) {
	switch v := e.(type) {
	case *ast.IntLit:
		// 0x.. ok; 0b.. -> decimal
		if hasPrefixAny(v.Value, "0x", "0X") {
			return v.Value, "int"
		}
		if hasPrefixAny(v.Value, "0b", "0B") {
			if n, err := strconv.ParseInt(v.Value[2:], 2, 64); err == nil {
				return strconv.FormatInt(n, 10), "int"
			}
			return "0", "int"
		}
		return v.Value, "int"
	case *ast.StrLit:
		return v.Value, "str"
	case *ast.BoolLit:
		if v.Value {
			return "1", "int"
		}
		return "0", "int"
	case *ast.IdentExpr:
		switch check.InferExprKind(info, v) {
		case check.KindStr:
			return v.Name, "str"
		case check.KindInt, check.KindBool, check.KindUnknown:
			return v.Name, "int"
		}
	case *ast.BinaryExpr:
		l, lk := cExprFor(v.Left, info)
		r, rk := cExprFor(v.Right, info)
		if lk == "int" && rk == "int" {
			return "(" + l + " " + v.Op + " " + r + ")", "int"
		}
		// (future) string concat lowering
		return "(" + l + " " + v.Op + " " + r + ")", ""
	case *ast.UnaryExpr:
		x, xk := cExprFor(v.X, info)
		if xk == "int" {
			return "(" + v.Op + x + ")", "int"
		}
		return "(" + v.Op + x + ")", ""
	case *ast.CallExpr:
		// io.println handled by caller; any other call not lowered
		return "0", ""
	case *ast.IndexExpr, *ast.FieldExpr:
		return "0", ""
	default:
		return "0", ""
	}
	return "0", ""
}

func spaces(n int) string {
	if n <= 0 {
		return ""
	}
	return string(bytes.Repeat([]byte(" "), n))
}

func hasPrefixAny(s string, p1, p2 string) bool {
	return (len(s) >= len(p1) && s[:len(p1)] == p1) ||
		(len(s) >= len(p2) && s[:len(p2)] == p2)
}
