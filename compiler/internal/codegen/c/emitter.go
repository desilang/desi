package c

import (
	"bytes"
	"strconv"
	"strings"

	"github.com/desilang/desi/compiler/internal/ast"
	"github.com/desilang/desi/compiler/internal/check"
	"github.com/desilang/desi/compiler/internal/term"
)

// ---- public entry ----

func EmitFile(f *ast.File, info *check.Info) string {
	var b bytes.Buffer
	term.Wprintf(&b, "/* generated by desic (Stage-1) */\n")
	term.Wprintf(&b, "#include <stdint.h>\n")
	term.Wprintf(&b, "#include <stdio.h>\n")
	term.Wprintf(&b, "#include <string.h>\n") // strcmp
	term.Wprintf(&b, "#include \"desi_std.h\"\n\n")

	sigs := collectFuncSigs(f)

	// Prototypes for non-main
	for _, d := range f.Decls {
		if fn, ok := d.(*ast.FuncDecl); ok && fn.Name != "main" {
			term.Wprintf(&b, "static %s %s(%s);\n",
				cType(sigs[fn.Name].ret), fn.Name, cParamList(fn))
		}
	}
	if len(sigs) > 0 {
		term.Wprintf(&b, "\n")
	}

	// Definitions (non-main first)
	for _, d := range f.Decls {
		if fn, ok := d.(*ast.FuncDecl); ok && fn.Name != "main" {
			emitFunc(&b, fn, sigs, info, false)
			term.Wprintf(&b, "\n")
		}
	}
	// Main last
	if m := findMain(f); m != nil {
		emitFunc(&b, m, sigs, info, true)
	}
	return b.String()
}

// ---- signatures & helpers ----

type sig struct {
	ret    string // "int"|"str"|"void"
	params []string
}

func collectFuncSigs(f *ast.File) map[string]sig {
	m := make(map[string]sig)
	for _, d := range f.Decls {
		fn, ok := d.(*ast.FuncDecl)
		if !ok {
			continue
		}
		s := sig{ret: typeToKind(fn.Ret)}
		for _, p := range fn.Params {
			s.params = append(s.params, typeToKind(p.Type))
		}
		m[fn.Name] = s
	}
	return m
}

func findMain(f *ast.File) *ast.FuncDecl {
	for _, d := range f.Decls {
		if fn, ok := d.(*ast.FuncDecl); ok && fn.Name == "main" {
			return fn
		}
	}
	return nil
}

func typeToKind(t string) string {
	t = strings.TrimSpace(strings.ToLower(t))
	switch t {
	case "", "void":
		return "void"
	case "i32", "int", "u32", "bool":
		return "int"
	case "str", "string":
		return "str"
	default:
		return "int"
	}
}

func cType(kind string) string {
	switch kind {
	case "void":
		return "void"
	case "str":
		return "const char*"
	default:
		return "int"
	}
}

func cParamList(fn *ast.FuncDecl) string {
	var parts []string
	for _, p := range fn.Params {
		parts = append(parts, cType(typeToKind(p.Type))+" "+p.Name)
	}
	return strings.Join(parts, ", ")
}

// ---- function/code emission ----

type env struct {
	fn      *ast.FuncDecl
	sigs    map[string]sig
	vars    map[string]string // name -> kind ("int"/"str")
	retKind string
	defers  []ast.Expr // function-scope defers (LIFO)
}

func emitFunc(b *bytes.Buffer, fn *ast.FuncDecl, sigs map[string]sig, info *check.Info, isMain bool) {
	e := &env{
		fn:      fn,
		sigs:    sigs,
		vars:    map[string]string{},
		retKind: typeToKind(fn.Ret),
		defers:  nil,
	}
	for _, p := range fn.Params {
		e.vars[p.Name] = typeToKind(p.Type)
	}

	// signature
	if isMain {
		term.Wprintf(b, "int main(void) {\n")
	} else {
		term.Wprintf(b, "static %s %s(%s) {\n",
			cType(e.retKind), fn.Name, cParamList(fn))
	}

	// body
	for _, s := range fn.Body {
		emitStmt(b, 2, s, e)
	}

	// On normal fallthrough, run defers then synthesize default return if needed.
	if len(e.defers) > 0 {
		emitDefers(b, 2, e)
	}
	if e.retKind != "void" && !hasTailReturn(fn.Body) {
		term.Wprintf(b, "  return 0;\n")
	}
	term.Wprintf(b, "}\n")
}

func hasTailReturn(body []ast.Stmt) bool {
	if len(body) == 0 {
		return false
	}
	_, ok := body[len(body)-1].(*ast.ReturnStmt)
	return ok
}

func emitStmt(b *bytes.Buffer, indent int, s ast.Stmt, e *env) {
	ind := spaces(indent)
	switch st := s.(type) {
	case *ast.LetStmt:
		cExpr, kind := cExprFor(st.Expr, e)
		if kind == "" {
			kind = "int"
		}
		e.vars[st.Name] = kind
		term.Wprintf(b, "%s%s %s = %s;\n", ind, cType(kind), st.Name, cExpr)

	case *ast.AssignStmt:
		cExpr, _ := cExprFor(st.Expr, e)
		term.Wprintf(b, "%s%s = %s;\n", ind, st.Name, cExpr)

	case *ast.ExprStmt:
		emitCallOrExpr(b, indent, st.Expr, e)

	case *ast.ReturnStmt:
		if len(e.defers) > 0 {
			emitDefers(b, indent, e)
		}
		if st.Expr == nil {
			if e.retKind == "void" {
				term.Wprintf(b, "%sreturn;\n", ind)
			} else {
				term.Wprintf(b, "%sreturn 0;\n", ind)
			}
			return
		}
		cExpr, kind := cExprFor(st.Expr, e)
		if e.retKind == "int" && kind != "int" {
			term.Wprintf(b, "%s/* non-int return; force 0 */\n", ind)
			term.Wprintf(b, "%sreturn 0;\n", ind)
			return
		}
		if e.retKind == "str" && kind != "str" {
			term.Wprintf(b, "%s/* non-str return; force \"\" */\n", ind)
			term.Wprintf(b, "%sreturn \"\";\n", ind)
			return
		}
		term.Wprintf(b, "%sreturn %s;\n", ind, cExpr)

	case *ast.IfStmt:
		cond, _ := cExprFor(st.Cond, e)
		term.Wprintf(b, "%sif (%s) {\n", ind, stripOuterParens(cond))
		for _, s2 := range st.Then {
			emitStmt(b, indent+2, s2, e)
		}
		term.Wprintf(b, "%s}", ind)
		for _, el := range st.Elifs {
			ec, _ := cExprFor(el.Cond, e)
			term.Wprintf(b, " else if (%s) {\n", stripOuterParens(ec))
			for _, s2 := range el.Body {
				emitStmt(b, indent+2, s2, e)
			}
			term.Wprintf(b, "%s}", ind)
		}
		if st.Else != nil {
			term.Wprintf(b, " else {\n")
			for _, s2 := range st.Else {
				emitStmt(b, indent+2, s2, e)
			}
			term.Wprintf(b, "%s}\n", ind)
		} else {
			term.Wprintf(b, "\n")
		}

	case *ast.WhileStmt:
		cond, _ := cExprFor(st.Cond, e)
		term.Wprintf(b, "%swhile (%s) {\n", ind, stripOuterParens(cond))
		for _, s2 := range st.Body {
			emitStmt(b, indent+2, s2, e)
		}
		term.Wprintf(b, "%s}\n", ind)

	case *ast.DeferStmt:
		e.defers = append(e.defers, st.Call)
		term.Wprintf(b, "%s/* defer scheduled */\n", ind)

	default:
		term.Wprintf(b, "%s/* stmt not lowered */\n", ind)
	}
}

func emitCallOrExpr(b *bytes.Buffer, indent int, expr ast.Expr, e *env) {
	ind := spaces(indent)
	// io.println(...): special-case to printf
	if call, ok := expr.(*ast.CallExpr); ok && isIoPrintln(call) {
		emitPrintln(b, indent, call, e)
		return
	}
	cx, _ := cExprFor(expr, e)
	term.Wprintf(b, "%s(void)(%s);\n", ind, cx)
}

func emitDefers(b *bytes.Buffer, indent int, e *env) {
	ind := spaces(indent)
	for i := len(e.defers) - 1; i >= 0; i-- {
		call := e.defers[i]
		if ce, ok := call.(*ast.CallExpr); ok && isIoPrintln(ce) {
			emitPrintln(b, indent, ce, e)
			continue
		}
		cx, _ := cExprFor(call, e)
		term.Wprintf(b, "%s/* defer */ (void)(%s);\n", ind, cx)
	}
}

func isIoPrintln(c *ast.CallExpr) bool {
	if fe, ok := c.Callee.(*ast.FieldExpr); ok && fe.Name == "println" {
		if id, ok := fe.X.(*ast.IdentExpr); ok && id.Name == "io" {
			return true
		}
	}
	return false
}

// Variadic println: io.println(a, b, c, ...)
// strings -> %s, ints/bools/unknown -> %d
func emitPrintln(b *bytes.Buffer, indent int, call *ast.CallExpr, e *env) {
	ind := spaces(indent)
	term.Wprintf(b, "%sprintf(", ind)
	term.Wprintf(b, "%s", buildPrintfArgs(call.Args, e))
	term.Wprintf(b, ");\n")
}

func buildPrintfArgs(args []ast.Expr, e *env) string {
	var fmt strings.Builder
	var argv []string
	fmt.WriteString("\"")
	if len(args) == 0 {
		fmt.WriteString("\\n\"")
		return fmt.String()
	}
	for _, a := range args {
		ce, kind := cExprFor(a, e)
		if kind == "str" {
			fmt.WriteString("%s")
		} else {
			fmt.WriteString("%d")
		}
		argv = append(argv, ce)
	}
	fmt.WriteString("\\n\"")
	if len(argv) > 0 {
		return fmt.String() + ", " + strings.Join(argv, ", ")
	}
	return fmt.String()
}

// ---- expressions ----

func cExprFor(e ast.Expr, env *env) (string, string) {
	switch v := e.(type) {
	case *ast.IntLit:
		if hasPrefixAny(v.Value, "0b", "0B") {
			if n, err := strconv.ParseInt(v.Value[2:], 2, 64); err == nil {
				return strconv.FormatInt(n, 10), "int"
			}
			return "0", "int"
		}
		return v.Value, "int"

	case *ast.StrLit:
		// Be robust: if Value already has quotes, keep; otherwise add quotes+escapes.
		return ensureCStringLiteral(v.Value), "str"

	case *ast.BoolLit:
		if v.Value {
			return "1", "int"
		}
		return "0", "int"

	case *ast.IdentExpr:
		if k, ok := env.vars[v.Name]; ok {
			return v.Name, k
		}
		return v.Name, "int"

	case *ast.UnaryExpr:
		x, k := cExprFor(v.X, env)
		op := v.Op
		if op == "not" {
			op = "!"
		}
		return "(" + op + " " + x + ")", k

	case *ast.BinaryExpr:
		l, lk := cExprFor(v.Left, env)
		r, rk := cExprFor(v.Right, env)

		// strcmp for string equality
		if (v.Op == "==" || v.Op == "!=") && (lk == "str" || rk == "str") {
			cmp := "strcmp(" + l + ", " + r + ")"
			if v.Op == "==" {
				return "(" + cmp + " == 0)", "int"
			}
			return "(" + cmp + " != 0)", "int"
		}
		// concat for '+' with strings
		if v.Op == "+" && (lk == "str" || rk == "str") {
			return "desi_str_concat(" + l + ", " + r + ")", "str"
		}

		// logical ops: and/or
		if v.Op == "and" {
			return "(" + l + " && " + r + ")", "int"
		}
		if v.Op == "or" {
			return "(" + l + " || " + r + ")", "int"
		}

		// default: emit as-is
		k := ""
		if lk == "str" || rk == "str" {
			k = "str"
		} else if lk == "int" && rk == "int" {
			k = "int"
		}
		return "(" + l + " " + v.Op + " " + r + ")", k

	case *ast.FieldExpr:
		// Not lowered in Stage-1 except for known std.* call-sites handled above.
		return "0", ""

	case *ast.IndexExpr:
		// Not lowered in Stage-1.
		return "0", ""

	case *ast.CallExpr:
		// Builtins / std shims
		if fe, ok := v.Callee.(*ast.FieldExpr); ok {
			if id, ok := fe.X.(*ast.IdentExpr); ok {
				switch id.Name + "." + fe.Name {
				case "fs.read_all":
					var args []string
					for _, a := range v.Args {
						ax, _ := cExprFor(a, env)
						args = append(args, ax)
					}
					return "desi_fs_read_all(" + strings.Join(args, ", ") + ")", "str"
				case "os.exit":
					var args []string
					for _, a := range v.Args {
						ax, _ := cExprFor(a, env)
						args = append(args, ax)
					}
					return "desi_os_exit(" + strings.Join(args, ", ") + ")", "void"
				case "mem.free":
					var args []string
					for _, a := range v.Args {
						ax, _ := cExprFor(a, env)
						args = append(args, ax)
					}
					return "(desi_mem_free(" + strings.Join(args, ", ") + "), 0)", "void"
				case "str.len":
					var args []string
					for _, a := range v.Args {
						ax, _ := cExprFor(a, env)
						args = append(args, ax)
					}
					return "desi_str_len(" + strings.Join(args, ", ") + ")", "int"
				case "str.at":
					var args []string
					for _, a := range v.Args {
						ax, _ := cExprFor(a, env)
						args = append(args, ax)
					}
					return "desi_str_at(" + strings.Join(args, ", ") + ")", "int"
				case "str.from_code":
					var args []string
					for _, a := range v.Args {
						ax, _ := cExprFor(a, env)
						args = append(args, ax)
					}
					return "desi_str_from_code(" + strings.Join(args, ", ") + ")", "str"
				}
			}
		}
		// user function call
		if id, ok := v.Callee.(*ast.IdentExpr); ok {
			if fs, ok := env.sigs[id.Name]; ok {
				var args []string
				for _, a := range v.Args {
					ax, _ := cExprFor(a, env)
					args = append(args, ax)
				}
				return id.Name + "(" + strings.Join(args, ", ") + ")", fs.ret
			}
		}
		return "0", ""

	default:
		return "0", ""
	}
}

// ---- helpers ----

func spaces(n int) string {
	if n <= 0 {
		return ""
	}
	return string(bytes.Repeat([]byte(" "), n))
}

func hasPrefixAny(s string, p1, p2 string) bool {
	return (len(s) >= len(p1) && s[:len(p1)] == p1) ||
		(len(s) >= len(p2) && s[:len(p2)] == p2)
}

func stripOuterParens(s string) string {
	s = strings.TrimSpace(s)
	if len(s) >= 2 && s[0] == '(' && s[len(s)-1] == ')' {
		depth := 0
		for i, r := range s {
			if r == '(' {
				depth++
			}
			if r == ')' {
				depth--
			}
			if depth == 0 && i != len(s)-1 {
				return s
			}
		}
		return strings.TrimSpace(s[1 : len(s)-1])
	}
	return s
}

// ensureCStringLiteral guarantees a valid, quoted C string literal.
// We strip any surrounding quotes if present, then always escape.
func ensureCStringLiteral(s string) string {
	s = strings.TrimSpace(s)
	if len(s) >= 2 && s[0] == '"' && s[len(s)-1] == '"' {
		s = s[1 : len(s)-1]
	}
	return quoteCLike(s)
}

// quoteCLike adds quotes and escapes: \" \\ \n \r \t and octal for other control chars.
func quoteCLike(s string) string {
	var b strings.Builder
	b.WriteByte('"')
	for _, r := range s {
		switch r {
		case '\\':
			b.WriteString(`\\`)
		case '"':
			b.WriteString(`\"`)
		case '\n':
			b.WriteString(`\n`)
		case '\r':
			b.WriteString(`\r`)
		case '\t':
			b.WriteString(`\t`)
		default:
			if r < 0x20 {
				o1 := ((r >> 6) & 7) + '0'
				o2 := ((r >> 3) & 7) + '0'
				o3 := (r & 7) + '0'
				b.WriteByte('\\')
				b.WriteByte(byte(o1))
				b.WriteByte(byte(o2))
				b.WriteByte(byte(o3))
			} else {
				b.WriteRune(r)
			}
		}
	}
	b.WriteByte('"')
	return b.String()
}
