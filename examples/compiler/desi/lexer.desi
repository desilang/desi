# Minimal Desi lexer (Stage-1)
# - decimal integers
# - strings "..." (no escapes)
# - identifiers & a few keywords
# - single-char ops/parens; 2-char: '==', '!=', ':=', '->', '<=', '>='
# - emits NEWLINE, INDENT, DEDENT
# - indentation policy:
#     * either 4 spaces per level
#     * or tabs (each tab counts as 2 spaces worth of indent)
#     * mixing tabs and spaces at line start → error
# - skips '#' comments
# - lex_file(path) wrapper
# - prints tokens as: io.println(kind, " ", text, " ", line, " ", col)

def is_space(c: int) -> int:
  return c == 32

def is_tab(c: int) -> int:
  return c == 9

def is_newline(c: int) -> int:
  return (c == 10) or (c == 13)

def is_digit(c: int) -> int:
  return (c >= 48) and (c <= 57)

def is_alpha(c: int) -> int:
  return ((c >= 65) and (c <= 90)) or ((c >= 97) and (c <= 122)) or (c == 95)

def is_alnum(c: int) -> int:
  let a = is_alpha(c)
  let d = is_digit(c)
  if (a == 1) or (d == 1):
    return 1
  return 0

def ch_at(s: str, i: int) -> int:
  return str.at(s, i)

def ch_str(c: int) -> str:
  return str.from_code(c)

# --- tiny string helpers (no arrays yet) ---

def str_len(s: str) -> int:
  return str.len(s)

def str_slice(s: str, lo: int, hi: int) -> str:
  let mut out = ""
  let mut j = lo
  while j < hi:
    out := out + ch_str(ch_at(s, j))
    j := j + 1
  return out

def int_to_str(n: int) -> str:
  if n == 0:
    return "0"
  let mut x = n
  let mut rev = ""
  while x > 0:
    let d = x % 10
    rev := rev + ch_str(48 + d)
    x := x / 10
  let m = str_len(rev)
  let mut i = m - 1
  let mut out = ""
  let mut done = 0
  while done == 0:
    out := out + ch_str(ch_at(rev, i))
    if i == 0:
      done := 1
    else:
      i := i - 1
  return out

def last_semicolon(s: str) -> int:
  let n = str_len(s)
  if n == 0:
    return -1
  let mut i = n - 1
  let mut found = -1
  let mut done = 0
  while (i >= 0) and (done == 0):
    let c = ch_at(s, i)
    if c == 59:
      found := i
      done := 1
    else:
      if i == 0:
        done := 1
      else:
        i := i - 1
  return found

def parse_int(s: str) -> int:
  let mut v = 0
  let n = str_len(s)
  let mut i = 0
  while i < n:
    let c = ch_at(s, i)
    if (c >= 48) and (c <= 57):
      v := (v * 10) + (c - 48)
      i := i + 1
    else:
      i := n
  return v

def stack_top(s: str) -> int:
  let sep = last_semicolon(s)
  if sep == -1:
    return parse_int(s)
  else:
    let tail = str_slice(s, sep + 1, str_len(s))
    return parse_int(tail)
  # explicit fall-through (defensive)
  return 0

def stack_push(s: str, n: int) -> str:
  return s + ";" + int_to_str(n)

def stack_pop(s: str) -> str:
  let sep = last_semicolon(s)
  if sep == -1:
    return "0"
  else:
    return str_slice(s, 0, sep)
  # explicit fall-through (defensive)
  return "0"

def starts_with(s: str, i: int, a: int, b: int) -> int:
  let n = str_len(s)
  if i + 1 >= n:
    return 0
  let c1 = ch_at(s, i)
  let c2 = ch_at(s, i + 1)
  if (c1 == a) and (c2 == b):
    return 1
  return 0

def is_keyword(name: str) -> int:
  if name == "def":
    return 1
  elif name == "if":
    return 1
  elif name == "else":
    return 1
  elif name == "elif":
    return 1
  elif name == "while":
    return 1
  elif name == "return":
    return 1
  elif name == "let":
    return 1
  elif name == "mut":
    return 1
  elif name == "true":
    return 1
  elif name == "false":
    return 1
  elif name == "and":
    return 1
  elif name == "or":
    return 1
  elif name == "not":
    return 1
  elif name == "package":
    return 1
  elif name == "import":
    return 1
  elif name == "defer":
    return 1
  return 0

def emit(kind: str, text: str, line: int, col: int) -> void:
  io.println(kind, " ", text, " ", line, " ", col)

def lex_file(path: str) -> int:
  let src = fs.read_all(path)
  return lex_string(src)

def lex_string(src: str) -> int:
  let n = str_len(src)
  let mut i = 0
  let mut line = 1
  let mut col = 1
  let mut indents = "0"   # stack "0;2;4;..."
  let mut mode = 0        # 0 unknown, 1 spaces, 2 tabs

  while i < n:
    let mut handled = 0
    let c = ch_at(src, i)

    # skip spaces inside a line
    if handled == 0 and is_space(c) == 1:
      i := i + 1
      col := col + 1
      handled := 1

    # comments: '#' to end-of-line
    elif handled == 0 and (c == 35):
      i := i + 1
      col := col + 1
      let mut done = 0
      while (i < n) and (done == 0):
        let d = ch_at(src, i)
        if is_newline(d) == 1:
          done := 1
        else:
          i := i + 1
          col := col + 1
      handled := 1

    # CR or CRLF → NEWLINE + compute indent for next line
    elif handled == 0 and (c == 13):
      emit("NEWLINE", "", line, col)
      if (i + 1 < n) and (ch_at(src, i + 1) == 10):
        i := i + 2
      else:
        i := i + 1
      line := line + 1
      col := 1

      # compute indent (tabs or spaces; no mixing)
      let mut j = i
      let mut indent = 0
      let mut seen_space = 0
      let mut seen_tab = 0
      let mut done2 = 0
      while (j < n) and (done2 == 0):
        let t = ch_at(src, j)
        if is_space(t) == 1:
          seen_space := 1
          indent := indent + 1
          j := j + 1
        elif is_tab(t) == 1:
          seen_tab := 1
          indent := indent + 2
          j := j + 1
        else:
          done2 := 1

      if (seen_space == 1) and (seen_tab == 1):
        emit("ERR", "mixed tabs and spaces in indentation", line, 1)

      if (mode == 0) and (indent > 0):
        if seen_tab == 1:
          mode := 2
        else:
          mode := 1

      let mut nextc = 0
      if j < n:
        nextc := ch_at(src, j)

      i := j
      col := 1 + indent

      if (nextc == 10) or (nextc == 13) or (nextc == 35):
        handled := 1
      else:
        let top = stack_top(indents)
        if indent > top:
          emit("INDENT", "", line, 1)
          indents := stack_push(indents, indent)
        elif indent < top:
          let mut cur = top
          while cur > indent:
            emit("DEDENT", "", line, 1)
            indents := stack_pop(indents)
            cur := stack_top(indents)
          if cur != indent:
            emit("ERR", "inconsistent indentation", line, 1)
        handled := 1

    # LF → NEWLINE + compute indent for next line
    elif handled == 0 and (c == 10):
      emit("NEWLINE", "", line, col)
      i := i + 1
      line := line + 1
      col := 1

      let mut j2 = i
      let mut indent2 = 0
      let mut seen_space2 = 0
      let mut seen_tab2 = 0
      let mut done3 = 0
      while (j2 < n) and (done3 == 0):
        let t2 = ch_at(src, j2)
        if is_space(t2) == 1:
          seen_space2 := 1
          indent2 := indent2 + 1
          j2 := j2 + 1
        elif is_tab(t2) == 1:
          seen_tab2 := 1
          indent2 := indent2 + 2
          j2 := j2 + 1
        else:
          done3 := 1

      if (seen_space2 == 1) and (seen_tab2 == 1):
        emit("ERR", "mixed tabs and spaces in indentation", line, 1)

      if (mode == 0) and (indent2 > 0):
        if seen_tab2 == 1:
          mode := 2
        else:
          mode := 1

      let mut nextc2 = 0
      if j2 < n:
        nextc2 := ch_at(src, j2)

      i := j2
      col := 1 + indent2

      if (nextc2 == 10) or (nextc2 == 13) or (nextc2 == 35):
        handled := 1
      else:
        let top2 = stack_top(indents)
        if indent2 > top2:
          emit("INDENT", "", line, 1)
          indents := stack_push(indents, indent2)
        elif indent2 < top2:
          let mut cur2 = top2
          while cur2 > indent2:
            emit("DEDENT", "", line, 1)
            indents := stack_pop(indents)
            cur2 := stack_top(indents)
          if cur2 != indent2:
            emit("ERR", "inconsistent indentation", line, 1)
        handled := 1

    # identifiers / keywords
    elif handled == 0 and is_alpha(c) == 1:
      let mut name = ""
      let start_col = col
      while (i < n) and (is_alnum(ch_at(src, i)) == 1):
        name := name + ch_str(ch_at(src, i))
        i := i + 1
        col := col + 1
      if is_keyword(name) == 1:
        emit("KW", name, line, start_col)
      else:
        emit("IDENT", name, line, start_col)
      handled := 1

    # integers (decimal)
    elif handled == 0 and is_digit(c) == 1:
      let mut lit = ""
      let start_col2 = col
      while (i < n) and (is_digit(ch_at(src, i)) == 1):
        lit := lit + ch_str(ch_at(src, i))
        i := i + 1
        col := col + 1
      emit("INT", lit, line, start_col2)
      handled := 1

    # strings "..." (no escapes)
    elif handled == 0 and (c == 34):
      let start_col3 = col
      i := i + 1
      col := col + 1
      let mut val = ""
      let mut closed = 0
      let mut done4 = 0
      while (i < n) and (done4 == 0):
        let d2 = ch_at(src, i)
        if d2 == 34:
          closed := 1
          i := i + 1
          col := col + 1
          done4 := 1
        elif is_newline(d2) == 1:
          done4 := 1
        else:
          val := val + ch_str(d2)
          i := i + 1
          col := col + 1
      if closed == 1:
        emit("STR", val, line, start_col3)
      else:
        emit("ERR", "unterminated string", line, start_col3)
      handled := 1

    # two-char tokens
    elif handled == 0 and (starts_with(src, i, 61, 61) == 1):
      emit("EQEQ", "==", line, col)
      i := i + 2
      col := col + 2
      handled := 1

    elif handled == 0 and (starts_with(src, i, 33, 61) == 1):
      emit("NE", "!=", line, col)
      i := i + 2
      col := col + 2
      handled := 1

    elif handled == 0 and (starts_with(src, i, 58, 61) == 1):
      emit("ASSIGN", ":=", line, col)
      i := i + 2
      col := col + 2
      handled := 1

    elif handled == 0 and (starts_with(src, i, 45, 62) == 1):
      emit("ARROW", "->", line, col)
      i := i + 2
      col := col + 2
      handled := 1

    elif handled == 0 and (starts_with(src, i, 60, 61) == 1):
      emit("LE", "<=", line, col)
      i := i + 2
      col := col + 2
      handled := 1

    elif handled == 0 and (starts_with(src, i, 62, 61) == 1):
      emit("GE", ">=", line, col)
      i := i + 2
      col := col + 2
      handled := 1

    elif handled == 0 and (starts_with(src, i, 124, 62) == 1):
      emit("PIPE", "|>", line, col)
      i := i + 2
      col := col + 2
      handled := 1

    # single-char tokens
    elif handled == 0 and (c == 40):
      emit("LPAREN", "(", line, col)
      i := i + 1
      col := col + 1
      handled := 1

    elif handled == 0 and (c == 41):
      emit("RPAREN", ")", line, col)
      i := i + 1
      col := col + 1
      handled := 1

    elif handled == 0 and (c == 44):
      emit("COMMA", ",", line, col)
      i := i + 1
      col := col + 1
      handled := 1

    elif handled == 0 and (c == 58):
      emit("COLON", ":", line, col)
      i := i + 1
      col := col + 1
      handled := 1

    elif handled == 0 and (c == 46):
      emit("DOT", ".", line, col)
      i := i + 1
      col := col + 1
      handled := 1

    elif handled == 0 and (c == 43):
      emit("PLUS", "+", line, col)
      i := i + 1
      col := col + 1
      handled := 1

    elif handled == 0 and (c == 45):
      emit("MINUS", "-", line, col)
      i := i + 1
      col := col + 1
      handled := 1

    elif handled == 0 and (c == 42):
      emit("STAR", "*", line, col)
      i := i + 1
      col := col + 1
      handled := 1

    elif handled == 0 and (c == 47):
      emit("SLASH", "/", line, col)
      i := i + 1
      col := col + 1
      handled := 1

    elif handled == 0 and (c == 37):
      emit("PERCENT", "%", line, col)
      i := i + 1
      col := col + 1
      handled := 1

    elif handled == 0 and (c == 61):
      emit("EQ", "=", line, col)
      i := i + 1
      col := col + 1
      handled := 1

    elif handled == 0 and (c == 60):
      emit("LT", "<", line, col)
      i := i + 1
      col := col + 1
      handled := 1

    elif handled == 0 and (c == 62):
      emit("GT", ">", line, col)
      i := i + 1
      col := col + 1
      handled := 1

    # unknown char
    if handled == 0:
      emit("ERR", "unknown char " + ch_str(c), line, col)
      i := i + 1
      col := col + 1

  # on EOF, emit any pending DEDENTs back to 0
  let mut top_final = stack_top(indents)
  while top_final > 0:
    emit("DEDENT", "", line, 1)
    indents := stack_pop(indents)
    top_final := stack_top(indents)

  emit("EOF", "", line, col)
  return 0
