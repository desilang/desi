# Minimal Desi lexer (Stage-1)
# - decimal integers
# - strings "..." with basic escapes: \" \\ \n \t \r
# - identifiers & a few keywords
# - single-char ops/parens; 2-char: '==', '!=', ':=', '->', '<=', '>='
# - emits NEWLINE, INDENT, DEDENT
# - indentation policy:
#     * either 4 spaces per level
#     * or tabs (each tab counts as 2 spaces worth of indent)
#     * mixing tabs and spaces at line start → error
# - skips '#' comments
# - lex_file(path) wrapper
# - printing demo:   lex_string(src) -> int  (prints tokens)
# - token sink demo: lex_tokens(src) -> str  (returns "KIND|TEXT|LINE|COL\n"...)

def is_space(c: int) -> int:
  return c == 32

def is_tab(c: int) -> int:
  return c == 9

def is_newline(c: int) -> int:
  return (c == 10) or (c == 13)

def is_digit(c: int) -> int:
  return (c >= 48) and (c <= 57)

def is_alpha(c: int) -> int:
  return ((c >= 65) and (c <= 90)) or ((c >= 97) and (c <= 122)) or (c == 95)

def is_alnum(c: int) -> int:
  let a = is_alpha(c)
  let d = is_digit(c)
  if (a == 1) or (d == 1):
    return 1
  return 0

def ch_at(s: str, i: int) -> int:
  return str.at(s, i)

def ch_str(c: int) -> str:
  return str.from_code(c)

# --- tiny string helpers (no arrays yet) ---

def str_len(s: str) -> int:
  return str.len(s)

def str_slice(s: str, lo: int, hi: int) -> str:
  let mut out = ""
  let mut j = lo
  while j < hi:
    out := out + ch_str(ch_at(s, j))
    j := j + 1
  return out

def int_to_str(n: int) -> str:
  if n == 0:
    return "0"
  let mut x = n
  let mut rev = ""
  while x > 0:
    let d = x % 10
    rev := rev + ch_str(48 + d)
    x := x / 10
  let m = str_len(rev)
  let mut i = m - 1
  let mut out = ""
  let mut done = 0
  while done == 0:
    out := out + ch_str(ch_at(rev, i))
    if i == 0:
      done := 1
    else:
      i := i - 1
  return out

def last_semicolon(s: str) -> int:
  let n = str_len(s)
  if n == 0:
    return -1
  let mut i = n - 1
  let mut found = -1
  let mut done = 0
  while (i >= 0) and (done == 0):
    let c = ch_at(s, i)
    if c == 59:
      found := i
      done := 1
    else:
      if i == 0:
        done := 1
      else:
        i := i - 1
  return found

def parse_int(s: str) -> int:
  let mut v = 0
  let n = str_len(s)
  let mut i = 0
  while i < n:
    let c = ch_at(s, i)
    if (c >= 48) and (c <= 57):
      v := (v * 10) + (c - 48)
      i := i + 1
    else:
      i := n
  return v

def stack_top(s: str) -> int:
  let sep = last_semicolon(s)
  if sep == -1:
    return parse_int(s)
  else:
    let tail = str_slice(s, sep + 1, str_len(s))
    return parse_int(tail)
  return 0

def stack_push(s: str, n: int) -> str:
  return s + ";" + int_to_str(n)

def stack_pop(s: str) -> str:
  let sep = last_semicolon(s)
  if sep == -1:
    return "0"
  else:
    return str_slice(s, 0, sep)
  return "0"

def starts_with(s: str, i: int, a: int, b: int) -> int:
  let n = str_len(s)
  if i + 1 >= n:
    return 0
  let c1 = ch_at(s, i)
  let c2 = ch_at(s, i + 1)
  if (c1 == a) and (c2 == b):
    return 1
  return 0

def is_keyword(name: str) -> int:
  if name == "def":
    return 1
  elif name == "if":
    return 1
  elif name == "else":
    return 1
  elif name == "elif":
    return 1
  elif name == "while":
    return 1
  elif name == "return":
    return 1
  elif name == "let":
    return 1
  elif name == "mut":
    return 1
  elif name == "true":
    return 1
  elif name == "false":
    return 1
  elif name == "and":
    return 1
  elif name == "or":
    return 1
  elif name == "not":
    return 1
  elif name == "package":
    return 1
  elif name == "import":
    return 1
  elif name == "defer":
    return 1
  return 0

# ------- Token sinks -------

# Print sink (legacy demo)
def emit(kind: str, text: str, line: int, col: int) -> void:
  io.println(kind, " ", text, " ", line, " ", col)

# Accumulator sink: returns new string with one encoded token line appended
def emit_to(acc: str, kind: str, text: str, line: int, col: int) -> str:
  let sline = int_to_str(line)
  let scol = int_to_str(col)
  # KIND|TEXT|LINE|COL\n
  let row = kind + "|" + text + "|" + sline + "|" + scol + "\n"
  return acc + row

def lex_file(path: str) -> int:
  let src = fs.read_all(path)
  return lex_string(src)

# Returns tokens as a single string ("K|T|L|C\n"...)
def lex_tokens(src: str) -> str:
  let n = str_len(src)
  let mut i = 0
  let mut line = 1
  let mut col = 1
  let mut indents = "0"
  let mut mode = 0
  let mut out = ""

  while i < n:
    let mut handled = 0
    let c = ch_at(src, i)

    if handled == 0 and is_space(c) == 1:
      i := i + 1
      col := col + 1
      handled := 1

    elif handled == 0 and (c == 35):
      i := i + 1
      col := col + 1
      let mut done = 0
      while (i < n) and (done == 0):
        let d = ch_at(src, i)
        if is_newline(d) == 1:
          done := 1
        else:
          i := i + 1
          col := col + 1
      handled := 1

    elif handled == 0 and (c == 13):
      out := emit_to(out, "NEWLINE", "", line, col)
      if (i + 1 < n) and (ch_at(src, i + 1) == 10):
        i := i + 2
      else:
        i := i + 1
      line := line + 1
      col := 1

      let mut j = i
      let mut indent = 0
      let mut seen_space = 0
      let mut seen_tab = 0
      let mut done2 = 0
      while (j < n) and (done2 == 0):
        let t = ch_at(src, j)
        if is_space(t) == 1:
          seen_space := 1
          indent := indent + 1
          j := j + 1
        elif is_tab(t) == 1:
          seen_tab := 1
          indent := indent + 2
          j := j + 1
        else:
          done2 := 1

      if (seen_space == 1) and (seen_tab == 1):
        out := emit_to(out, "ERR", "mixed tabs and spaces in indentation", line, 1)

      if (mode == 0) and (indent > 0):
        if seen_tab == 1:
          mode := 2
        else:
          mode := 1

      let mut nextc = 0
      if j < n:
        nextc := ch_at(src, j)

      i := j
      col := 1 + indent

      if (nextc == 10) or (nextc == 13) or (nextc == 35):
        handled := 1
      else:
        let top = stack_top(indents)
        if indent > top:
          out := emit_to(out, "INDENT", "", line, 1)
          indents := stack_push(indents, indent)
        elif indent < top:
          let mut cur = top
          while cur > indent:
            out := emit_to(out, "DEDENT", "", line, 1)
            indents := stack_pop(indents)
            cur := stack_top(indents)
          if cur != indent:
            out := emit_to(out, "ERR", "inconsistent indentation", line, 1)
        handled := 1

    elif handled == 0 and (c == 10):
      out := emit_to(out, "NEWLINE", "", line, col)
      i := i + 1
      line := line + 1
      col := 1

      let mut j2 = i
      let mut indent2 = 0
      let mut seen_space2 = 0
      let mut seen_tab2 = 0
      let mut done3 = 0
      while (j2 < n) and (done3 == 0):
        let t2 = ch_at(src, j2)
        if is_space(t2) == 1:
          seen_space2 := 1
          indent2 := indent2 + 1
          j2 := j2 + 1
        elif is_tab(t2) == 1:
          seen_tab2 := 1
          indent2 := indent2 + 2
          j2 := j2 + 1
        else:
          done3 := 1

      if (seen_space2 == 1) and (seen_tab2 == 1):
        out := emit_to(out, "ERR", "mixed tabs and spaces in indentation", line, 1)

      if (mode == 0) and (indent2 > 0):
        if seen_tab2 == 1:
          mode := 2
        else:
          mode := 1

      let mut nextc2 = 0
      if j2 < n:
        nextc2 := ch_at(src, j2)

      i := j2
      col := 1 + indent2

      if (nextc2 == 10) or (nextc2 == 13) or (nextc2 == 35):
        handled := 1
      else:
        let top2 = stack_top(indents)
        if indent2 > top2:
          out := emit_to(out, "INDENT", "", line, 1)
          indents := stack_push(indents, indent2)
        elif indent2 < top2:
          let mut cur2 = top2
          while cur2 > indent2:
            out := emit_to(out, "DEDENT", "", line, 1)
            indents := stack_pop(indents)
            cur2 := stack_top(indents)
          if cur2 != indent2:
            out := emit_to(out, "ERR", "inconsistent indentation", line, 1)
        handled := 1

    elif handled == 0 and is_alpha(c) == 1:
      let mut name = ""
      let start_col = col
      while (i < n) and (is_alnum(ch_at(src, i)) == 1):
        name := name + ch_str(ch_at(src, i))
        i := i + 1
        col := col + 1
      if is_keyword(name) == 1:
        out := emit_to(out, "KW", name, line, start_col)
      else:
        out := emit_to(out, "IDENT", name, line, start_col)
      handled := 1

    elif handled == 0 and is_digit(c) == 1:
      let mut lit = ""
      let start_col2 = col
      while (i < n) and (is_digit(ch_at(src, i)) == 1):
        lit := lit + ch_str(ch_at(src, i))
        i := i + 1
        col := col + 1
      out := emit_to(out, "INT", lit, line, start_col2)
      handled := 1

    elif handled == 0 and (c == 34):
      let start_col3 = col
      i := i + 1
      col := col + 1
      let mut val = ""
      let mut closed = 0
      let mut done4 = 0
      while (i < n) and (done4 == 0):
        let d2 = ch_at(src, i)
        if d2 == 34:
          closed := 1
          i := i + 1
          col := col + 1
          done4 := 1
        elif d2 == 92:            # backslash '\'
          if i + 1 < n:
            let e = ch_at(src, i + 1)
            if e == 110:         # \n
              val := val + ch_str(10)
              i := i + 2
              col := col + 2
            elif e == 116:       # \t
              val := val + ch_str(9)
              i := i + 2
              col := col + 2
            elif e == 114:       # \r
              val := val + ch_str(13)
              i := i + 2
              col := col + 2
            elif e == 34:        # \"
              val := val + ch_str(34)
              i := i + 2
              col := col + 2
            elif e == 92:        # \\
              val := val + ch_str(92)
              i := i + 2
              col := col + 2
            else:
              # unknown escape -> include literally
              val := val + ch_str(92)
              val := val + ch_str(e)
              i := i + 2
              col := col + 2
          else:
            # dangling backslash at end-of-input → error + stop string
            out := emit_to(out, "ERR", "unterminated string", line, start_col3)
            done4 := 1
        elif is_newline(d2) == 1:
          done4 := 1
        else:
          val := val + ch_str(d2)
          i := i + 1
          col := col + 1
      if closed == 1:
        out := emit_to(out, "STR", val, line, start_col3)
      else:
        out := emit_to(out, "ERR", "unterminated string", line, start_col3)
      handled := 1

    elif handled == 0 and (starts_with(src, i, 61, 61) == 1):
      out := emit_to(out, "EQEQ", "==", line, col)
      i := i + 2
      col := col + 2
      handled := 1

    elif handled == 0 and (starts_with(src, i, 33, 61) == 1):
      out := emit_to(out, "NE", "!=", line, col)
      i := i + 2
      col := col + 2
      handled := 1

    elif handled == 0 and (starts_with(src, i, 58, 61) == 1):
      out := emit_to(out, "ASSIGN", ":=", line, col)
      i := i + 2
      col := col + 2
      handled := 1

    elif handled == 0 and (starts_with(src, i, 45, 62) == 1):
      out := emit_to(out, "ARROW", "->", line, col)
      i := i + 2
      col := col + 2
      handled := 1

    elif handled == 0 and (starts_with(src, i, 60, 61) == 1):
      out := emit_to(out, "LE", "<=", line, col)
      i := i + 2
      col := col + 2
      handled := 1

    elif handled == 0 and (starts_with(src, i, 62, 61) == 1):
      out := emit_to(out, "GE", ">=", line, col)
      i := i + 2
      col := col + 2
      handled := 1

    elif handled == 0 and (starts_with(src, i, 124, 62) == 1):
      out := emit_to(out, "PIPE", "|>", line, col)
      i := i + 2
      col := col + 2
      handled := 1

    elif handled == 0 and (c == 40):
      out := emit_to(out, "LPAREN", "(", line, col)
      i := i + 1
      col := col + 1
      handled := 1

    elif handled == 0 and (c == 41):
      out := emit_to(out, "RPAREN", ")", line, col)
      i := i + 1
      col := col + 1
      handled := 1

    elif handled == 0 and (c == 44):
      out := emit_to(out, "COMMA", ",", line, col)
      i := i + 1
      col := col + 1
      handled := 1

    elif handled == 0 and (c == 58):
      out := emit_to(out, "COLON", ":", line, col)
      i := i + 1
      col := col + 1
      handled := 1

    elif handled == 0 and (c == 46):
      out := emit_to(out, "DOT", ".", line, col)
      i := i + 1
      col := col + 1
      handled := 1

    elif handled == 0 and (c == 43):
      out := emit_to(out, "PLUS", "+", line, col)
      i := i + 1
      col := col + 1
      handled := 1

    elif handled == 0 and (c == 45):
      out := emit_to(out, "MINUS", "-", line, col)
      i := i + 1
      col := col + 1
      handled := 1

    elif handled == 0 and (c == 42):
      out := emit_to(out, "STAR", "*", line, col)
      i := i + 1
      col := col + 1
      handled := 1

    elif handled == 0 and (c == 47):
      out := emit_to(out, "SLASH", "/", line, col)
      i := i + 1
      col := col + 1
      handled := 1

    elif handled == 0 and (c == 37):
      out := emit_to(out, "PERCENT", "%", line, col)
      i := i + 1
      col := col + 1
      handled := 1

    elif handled == 0 and (c == 61):
      out := emit_to(out, "EQ", "=", line, col)
      i := i + 1
      col := col + 1
      handled := 1

    elif handled == 0 and (c == 60):
      out := emit_to(out, "LT", "<", line, col)
      i := i + 1
      col := col + 1
      handled := 1

    elif handled == 0 and (c == 62):
      out := emit_to(out, "GT", ">", line, col)
      i := i + 1
      col := col + 1
      handled := 1

    if handled == 0:
      out := emit_to(out, "ERR", "unknown char " + ch_str(c), line, col)
      i := i + 1
      col := col + 1

  let mut top_final = stack_top(indents)
  while top_final > 0:
    out := emit_to(out, "DEDENT", "", line, 1)
    indents := stack_pop(indents)
    top_final := stack_top(indents)

  out := emit_to(out, "EOF", "", line, col)
  return out

# Legacy printer (kept for old demo)
def lex_string(src: str) -> int:
  let toks = lex_tokens(src)
  io.println(toks)
  return 0
