# Minimal Desi lexer (Stage-1)
# - decimal integers
# - strings "..." with basic escapes preserved verbatim: \" \\ \n \t \r
#   (we *do not* insert real control chars in token text to keep raw K|T|L|C safe)
# - identifiers & a few keywords
# - single-char ops/parens; 2-char: '==', '!=', ':=', '->', '<=', '>='
# - emits NEWLINE, INDENT, DEDENT
# - indentation policy:
#     * either 4 spaces per level
#     * or tabs (each tab counts as 2 spaces worth of indent)
#     * mixing tabs and spaces at line start → error
# - skips '#' comments
# - lex_file(path) wrapper
# - printing demo:   lex_string(src) -> int  (prints tokens)
# - token sink demo: lex_tokens(src) -> str  (returns "KIND|TEXT|LINE|COL\n"...)

def is_space(c: int) -> int:
  return c == 32

def is_tab(c: int) -> int:
  return c == 9

def is_newline(c: int) -> int:
  return (c == 10) or (c == 13)

def is_digit(c: int) -> int:
  return (c >= 48) and (c <= 57)

def is_alpha(c: int) -> int:
  return ((c >= 65) and (c <= 90)) or ((c >= 97) and (c <= 122)) or (c == 95)

def is_alnum(c: int) -> int:
  let a = is_alpha(c)
  let d = is_digit(c)
  if (a == 1) or (d == 1):
    return 1
  return 0

def ch_at(s: str, i: int) -> int:
  return str.at(s, i)

def ch_str(c: int) -> str:
  return str.from_code(c)

# --- tiny string helpers (no arrays yet) ---

def str_len(s: str) -> int:
  return str.len(s)

def str_slice(s: str, lo: int, hi: int) -> str:
  let mut out = ""
  let mut j = lo
  while j < hi:
    out := out + ch_str(ch_at(s, j))
    j := j + 1
  return out

def int_to_str(n: int) -> str:
  if n == 0:
    return "0"
  let mut x = n
  let mut rev = ""
  while x > 0:
    let d = x % 10
    rev := rev + ch_str(48 + d)
    x := x / 10
  let m = str_len(rev)
  let mut i = m - 1
  let mut out = ""
  let mut done = 0
  while done == 0:
    out := out + ch_str(ch_at(rev, i))
    if i == 0:
      done := 1
    else:
      i := i - 1
  return out

def last_semicolon(s: str) -> int:
  let n = str_len(s)
  if n == 0:
    return -1
  let mut i = n - 1
  let mut found = -1
  let mut done = 0
  while (i >= 0) and (done == 0):
    let c = ch_at(s, i)
    if c == 59:
      found := i
      done := 1
    else:
      if i == 0:
        done := 1
      else:
        i := i - 1
  return found

def parse_int(s: str) -> int:
  let mut v = 0
  let n = str_len(s)
  let mut i = 0
  while i < n:
    let c = ch_at(s, i)
    if (c >= 48) and (c <= 57):
      v := (v * 10) + (c - 48)
      i := i + 1
    else:
      i := n
  return v

def stack_top(s: str) -> int:
  let sep = last_semicolon(s)
  if sep == -1:
    return parse_int(s)
  else:
    let tail = str_slice(s, sep + 1, str_len(s))
    return parse_int(tail)
  return 0

def stack_push(s: str, n: int) -> str:
  return s + ";" + int_to_str(n)

def stack_pop(s: str) -> str:
  let sep = last_semicolon(s)
  if sep == -1:
    return "0"
  else:
    return str_slice(s, 0, sep)
  return "0"

def starts_with(s: str, i: int, a: int, b: int) -> int:
  let n = str_len(s)
  if i + 1 >= n:
    return 0
  let c1 = ch_at(s, i)
  let c2 = ch_at(s, i + 1)
  if (c1 == a) and (c2 == b):
    return 1
  return 0

# JSON-escape a string value (no bit shifts; Stage-0 friendly)
def json_escape(s: str) -> str:
  let n = str_len(s)
  let mut i = 0
  let mut out = ""
  while i < n:
    let c = ch_at(s, i)
    if c == 34:        # "
      out := out + "\\\""
    elif c == 92:      # \
      out := out + "\\\\"
    elif c == 8:       # \b
      out := out + "\\b"
    elif c == 12:      # \f
      out := out + "\\f"
    elif c == 10:      # \n
      out := out + "\\n"
    elif c == 13:      # \r
      out := out + "\\r"
    elif c == 9:       # \t
      out := out + "\\t"
    else:
      if c < 32:
        let hi = (c / 16) % 16
        let lo = c % 16
        let mut hx = ""
        if hi < 10:
          hx := ch_str(48 + hi)
        else:
          hx := ch_str(55 + hi)   # 'A'..'F'
        if lo < 10:
          hx := hx + ch_str(48 + lo)
        else:
          hx := hx + ch_str(55 + lo)
        out := out + "\\u00" + hx
      else:
        out := out + ch_str(c)
    i := i + 1
  return out


def is_keyword(name: str) -> int:
  if name == "def":
    return 1
  elif name == "if":
    return 1
  elif name == "else":
    return 1
  elif name == "elif":
    return 1
  elif name == "while":
    return 1
  elif name == "return":
    return 1
  elif name == "let":
    return 1
  elif name == "mut":
    return 1
  elif name == "true":
    return 1
  elif name == "false":
    return 1
  elif name == "and":
    return 1
  elif name == "or":
    return 1
  elif name == "not":
    return 1
  elif name == "package":
    return 1
  elif name == "import":
    return 1
  elif name == "defer":
    return 1
  return 0

# ------- Token sinks -------

# Print sink (legacy demo)
def emit(kind: str, text: str, line: int, col: int) -> void:
  io.println(kind, " ", text, " ", line, " ", col)

# Escape TEXT field for raw rows so the '|' field separator is unambiguous.
# We encode '\' as '\\' and '|' as '\|'.
def enc_field(s: str) -> str:
  let n = str_len(s)
  let mut i = 0
  let mut out = ""
  while i < n:
    let c = ch_at(s, i)
    if c == 92:         # '\'
      out := out + "\\\\"
    elif c == 124:      # '|'
      out := out + "\\|"
    else:
      out := out + ch_str(c)
    i := i + 1
  return out

# Accumulator sink: returns new string with one encoded token line appended
def emit_to(acc: str, kind: str, text: str, line: int, col: int) -> str:
  let sline = int_to_str(line)
  let scol  = int_to_str(col)
  let jtext = json_escape(text)
  let q  = ch_str(34)
  let nl = ch_str(10)
  let mut row = "{"
  row := row + q + "kind" + q + ":" + q + kind + q + ","
  row := row + q + "text" + q + ":" + q + jtext + q + ","
  row := row + q + "line" + q + ":" + sline + ","
  row := row + q + "col"  + q + ":" + scol + "}"
  row := row + nl
  return acc + row


def lex_file(path: str) -> int:
  let src = fs.read_all(path)
  return lex_string(src)

# Returns tokens as a single string ("K|T|L|C\n"...)
def lex_tokens(src: str) -> str:
  let n = str_len(src)
  let mut i = 0
  let mut line = 1
  let mut col = 1
  let mut indents = "0"
  let mut mode = 0
  let mut out = ""

  while i < n:
    let mut handled = 0
    let c = ch_at(src, i)

    # spaces
    if handled == 0 and is_space(c) == 1:
      i := i + 1
      col := col + 1
      handled := 1

    # line comment: '#....<EOL>' (we do not emit NEWLINE here; we let the EOL handler below do it)
    elif handled == 0 and (c == 35):
      # consume until (but not including) newline
      i := i + 1
      col := col + 1
      let mut done = 0
      while (i < n) and (done == 0):
        let d = ch_at(src, i)
        if is_newline(d) == 1:
          done := 1
        else:
          i := i + 1
          col := col + 1
      handled := 1

    # CR or LF — collapse runs of blank/comment-only logical lines into ONE NEWLINE,
    # then compute indentation for the first non-blank, non-comment line.
    elif handled == 0 and ((c == 13) or (c == 10)):
      # normalize: consume CRLF as one logical newline
      if c == 13 and (i + 1 < n) and (ch_at(src, i + 1) == 10):
        i := i + 2
      else:
        i := i + 1
      out := emit_to(out, "NEWLINE", "", line, col)
      line := line + 1
      col := 1

      # Now skip over any number of blank or comment-only lines, but don't emit
      # more NEWLINEs for them. Track indentation of the first code line we find.
      let mut j = i
      let mut indent = 0
      let mut seen_space = 0
      let mut seen_tab = 0
      let mut have_code_line = 0

      while (j < n) and (have_code_line == 0):
        # measure indentation (spaces/tabs) for this physical line
        indent := 0
        seen_space := 0
        seen_tab := 0
        let mut k = j
        let mut done_ind = 0
        while (k < n) and (done_ind == 0):
          let t = ch_at(src, k)
          if is_space(t) == 1:
            seen_space := 1
            indent := indent + 1
            k := k + 1
          elif is_tab(t) == 1:
            seen_tab := 1
            indent := indent + 2
            k := k + 1
          else:
            done_ind := 1

        # empty line? (next is EOL)
        let mut nextc = 0
        if k < n:
          nextc := ch_at(src, k)

        if (nextc == 35):
          # comment-only line → skip whole physical line, no NEWLINE emitted
          # consume until EOL and then the EOL itself
          k := k + 1
          let mut done_c = 0
          while (k < n) and (done_c == 0):
            let d = ch_at(src, k)
            if is_newline(d) == 1:
              done_c := 1
            else:
              k := k + 1
          # consume EOL (CRLF or LF)
          if (k < n) and (ch_at(src, k) == 13) and ((k + 1) < n) and (ch_at(src, k + 1) == 10):
            k := k + 2
          elif (k < n) and (ch_at(src, k) == 10):
            k := k + 1
          # advance j and logical line number; do NOT emit another NEWLINE token
          j := k
          line := line + 1
          # continue scanning next physical line
        elif (nextc == 10) or (nextc == 13):
          # blank line → consume the EOL; advance; do NOT emit another NEWLINE
          if (ch_at(src, k) == 13) and ((k + 1) < n) and (ch_at(src, k + 1) == 10):
            j := k + 2
          else:
            j := k + 1
          line := line + 1
          # continue scanning next physical line
        else:
          # first non-blank, non-comment line → we will use its indent
          have_code_line := 1
          i := k
          # set current column to indent + 1 for that line
          col := 1 + indent

          if (seen_space == 1) and (seen_tab == 1):
            out := emit_to(out, "ERR", "mixed tabs and spaces in indentation", line, 1)

          if (mode == 0) and (indent > 0):
            if seen_tab == 1:
              mode := 2
            else:
              mode := 1

          # compare indent vs stack and emit INDENT/DEDENTs now
          let top = stack_top(indents)
          if indent > top:
            out := emit_to(out, "INDENT", "", line, 1)
            indents := stack_push(indents, indent)
          elif indent < top:
            let mut cur = top
            while cur > indent:
              out := emit_to(out, "DEDENT", "", line, 1)
              indents := stack_pop(indents)
              cur := stack_top(indents)
            if cur != indent:
              out := emit_to(out, "ERR", "inconsistent indentation", line, 1)

      handled := 1

    # identifiers / keywords
    elif handled == 0 and is_alpha(c) == 1:
      let mut name = ""
      let start_col = col
      while (i < n) and (is_alnum(ch_at(src, i)) == 1):
        name := name + ch_str(ch_at(src, i))
        i := i + 1
        col := col + 1
      if is_keyword(name) == 1:
        out := emit_to(out, "KW", name, line, start_col)
      else:
        out := emit_to(out, "IDENT", name, line, start_col)
      handled := 1

    # integer literal
    elif handled == 0 and is_digit(c) == 1:
      let mut lit = ""
      let start_col2 = col
      while (i < n) and (is_digit(ch_at(src, i)) == 1):
        lit := lit + ch_str(ch_at(src, i))
        i := i + 1
        col := col + 1
      out := emit_to(out, "INT", lit, line, start_col2)
      handled := 1

    # string literal
    elif handled == 0 and (c == 34):
      let start_col3 = col
      i := i + 1
      col := col + 1
      let mut val = ""
      let mut closed = 0
      let mut done4 = 0
      while (i < n) and (done4 == 0):
        let d2 = ch_at(src, i)
        if d2 == 34:
          closed := 1
          i := i + 1
          col := col + 1
          done4 := 1
        elif d2 == 92:
          if (i + 1) < n:
            let e = ch_at(src, i + 1)
            val := val + ch_str(92) + ch_str(e)
            i := i + 2
            col := col + 2
          else:
            done4 := 1
        elif is_newline(d2) == 1:
          done4 := 1
        else:
          val := val + ch_str(d2)
          i := i + 1
          col := col + 1
      if closed == 1:
        out := emit_to(out, "STR", val, line, start_col3)
      else:
        out := emit_to(out, "ERR", "unterminated string", line, start_col3)
      handled := 1

    # two-char ops
    elif handled == 0 and (starts_with(src, i, 61, 61) == 1):
      out := emit_to(out, "EQEQ", "==", line, col)
      i := i + 2
      col := col + 2
      handled := 1

    elif handled == 0 and (starts_with(src, i, 33, 61) == 1):
      out := emit_to(out, "NE", "!=", line, col)
      i := i + 2
      col := col + 2
      handled := 1

    elif handled == 0 and (starts_with(src, i, 58, 61) == 1):
      out := emit_to(out, "ASSIGN", ":=", line, col)
      i := i + 2
      col := col + 2
      handled := 1

    elif handled == 0 and (starts_with(src, i, 45, 62) == 1):
      out := emit_to(out, "ARROW", "->", line, col)
      i := i + 2
      col := col + 2
      handled := 1

    elif handled == 0 and (starts_with(src, i, 60, 61) == 1):
      out := emit_to(out, "LE", "<=", line, col)
      i := i + 2
      col := col + 2
      handled := 1

    elif handled == 0 and (starts_with(src, i, 62, 61) == 1):
      out := emit_to(out, "GE", ">=", line, col)
      i := i + 2
      col := col + 2
      handled := 1

    elif handled == 0 and (starts_with(src, i, 124, 62) == 1):
      out := emit_to(out, "PIPE", "|>", line, col)
      i := i + 2
      col := col + 2
      handled := 1

    # single-char tokens
    elif handled == 0 and (c == 40):
      out := emit_to(out, "LPAREN", "(", line, col)
      i := i + 1
      col := col + 1
      handled := 1

    elif handled == 0 and (c == 41):
      out := emit_to(out, "RPAREN", ")", line, col)
      i := i + 1
      col := col + 1
      handled := 1

    elif handled == 0 and (c == 44):
      out := emit_to(out, "COMMA", ",", line, col)
      i := i + 1
      col := col + 1
      handled := 1

    elif handled == 0 and (c == 58):
      out := emit_to(out, "COLON", ":", line, col)
      i := i + 1
      col := col + 1
      handled := 1

    elif handled == 0 and (c == 46):
      out := emit_to(out, "DOT", ".", line, col)
      i := i + 1
      col := col + 1
      handled := 1

    elif handled == 0 and (c == 43):
      out := emit_to(out, "PLUS", "+", line, col)
      i := i + 1
      col := col + 1
      handled := 1

    elif handled == 0 and (c == 45):
      out := emit_to(out, "MINUS", "-", line, col)
      i := i + 1
      col := col + 1
      handled := 1

    elif handled == 0 and (c == 42):
      out := emit_to(out, "STAR", "*", line, col)
      i := i + 1
      col := col + 1
      handled := 1

    elif handled == 0 and (c == 47):
      out := emit_to(out, "SLASH", "/", line, col)
      i := i + 1
      col := col + 1
      handled := 1

    elif handled == 0 and (c == 37):
      out := emit_to(out, "PERCENT", "%", line, col)
      i := i + 1
      col := col + 1
      handled := 1

    elif handled == 0 and (c == 61):
      out := emit_to(out, "EQ", "=", line, col)
      i := i + 1
      col := col + 1
      handled := 1

    elif handled == 0 and (c == 60):
      out := emit_to(out, "LT", "<", line, col)
      i := i + 1
      col := col + 1
      handled := 1

    elif handled == 0 and (c == 62):
      out := emit_to(out, "GT", ">", line, col)
      i := i + 1
      col := col + 1
      handled := 1

    # unknown
    if handled == 0:
      out := emit_to(out, "ERR", "unknown char " + ch_str(c), line, col)
      i := i + 1
      col := col + 1

  # unwind indentation at EOF
  let mut top_final = stack_top(indents)
  while top_final > 0:
    out := emit_to(out, "DEDENT", "", line, 1)
    indents := stack_pop(indents)
    top_final := stack_top(indents)

  out := emit_to(out, "EOF", "", line, col)
  return out

# Legacy printer (kept for old demo)
def lex_string(src: str) -> int:
  let toks = lex_tokens(src)
  io.println(toks)
  return 0
